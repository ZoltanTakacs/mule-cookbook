:mule: Mule Cook Book

== Adding DataSense

=== What is it?

http://www.mulesoft.org/documentation/display/current/DataSense[DataSense] is a feature used to improve the user experience at design time when creating Mule applications.

If coded correctly, user will be able to take advantage of the messages metadata to facilitate application design. With this functionality, Anypoint(TM) Studio proactively acquires information about data, such as data type and structure, in order to prescribe how to accurately map or use data in your application.

Is feature that displays the metadata of the entities included in the service in a friendly manner. Although this feature is optional, Mule strongly recommends that you use DataSense in your connector much easier to use for end users.

Full documentation is available http://www.mulesoft.org/documentation/display/current/Adding+DataSense[here].

=== How to implement it

==== My model is static

When we say that a model is static, it mean that the entities are fixed and know and cannot change in anyway. The fields it supports are fixed.

Lets analyze the entities in {mule} service. We just have 2 simple entities, Recipe and Ingredient that extends from CookBookEntity.

Now, lets take a look at how our createIngredient operation looks inside Anypoint Studio. And how it interacts with other components.

[source,java,indent=0]
----
include::{resourcesDir}/java/v3/CookBookConnector.java[lines=66..70]
----

We defined the operation so that it receives an Ingredient, and it return the Ingredient with the extra fields populated form the server.

If we check the input metadata, we can see that the expected output is a Pojo, with the expected fields our Ingredient has:

image::datasense.png[width="900"]

If we verify the output metadata, it is also the expected one.

image::datasense2.png[width="900"]

So now, if we drag and drop a datamapper either behind or after our connector, we will see that datamapper automatically picks the input or output.

image::datamapper-input1.png[title="Datamapper Receiving Connector Output ", width="900"]

image::datamapper-output1.png[title="Datamapper Setting Connector Input",width="900"]

Because DevKit auto generates static meta data, your connector know how propagate meta data information.

But we don't have just Ingredients, we also have Recipes, but we don't want to have one method for each entity we have in our model.

So lets make some modifications so that we just work with the CookBookEntity class.

Here we have our new create operation.
[source,java,indent=0]
----
include::{resourcesDir}/java/v4/CookBookConnector.java[lines=67..72]
----

Because of some devkit limitations regarding how to handle Abstract classes, we need to specify that the input can only be specified as a reference.

But lets see how this affects the UI and user experience.

Studio, can no longer determine input or output type:

image::ref-only-input.png[title="Connector Input with @RefOnly",width="900"]

image::ref-only-output.png[title="Connector Output with Abstract Class",width="900"]

And even in datamapper is not automatically populated, with the type:

image::ref-only-datamapper.png[title="Datamapper with connector with @RefOnly parameter",width="900"]

We are forced to manually configure the input:

image::manual-datamapper.png[title="Selecting the pojo manually",width="900"]

In the next section we will see how me can get back our datamapper friendly user experience.

==== Implementing adding @MetaDataCategory

In order to implement DataSense using a @MetaDataCategory you need to separate your implementation in 2 steps, retrieving the keys and then describing the keys.

First, we will annotate our retriever with the @MetaDataCategory and inject the connector (this last one is a requirement in the current devkit version).
[source,java,indent=0]
----
include::{resourcesDir}/java/v5/DataSenseResolver.java[lines=31..36]
----

Then, we need a method that retrieves the keys, which we will annotate with @MetaDataKeyRetriever:
[source,java,indent=0]
----
include::{resourcesDir}/java/v5/DataSenseResolver.java[lines=40..49]
----

Now, we need a method that describes an entity fiven a keys, which we will annotate with @MetaDataRetriever, since we are using a static model, we can just create a PojoModel:
[source,java,indent=0]
----
include::{resourcesDir}/java/v5/DataSenseResolver.java[lines=60..76]
----

Check the full link:{resourcesDir}/java/v5/DataSenseResolver.java[source code].

Now, in order to use this in our connector we need to modify our @Processors so that the user can pick the entities.

Lets annotate our @Connector class with the @MetaDataScope annotation. This will set the default MetaDataCategory that will be used every time the users chooses a @Processor that has a @MetaDataKeyParam.
[source,java,indent=0]
----
include::{resourcesDir}/java/v5/CookBookConnector.java[lines=37..39]
----

In order to describe input and output, we need to tune our @Processor:
[source,java,indent=0]
----
include::{resourcesDir}/java/v5/CookBookConnector.java[lines=71..77]
----

In our get operation we need to affect only output so we will modify it just a little:
[source,java,indent=0]
----
include::{resourcesDir}/java/v5/CookBookConnector.java[lines=110..115]
----

Lets check our our new connector looks in studio.

Now, we have a combo that after we select the entity type and save it, will automatically refresh our MetaData.

image::datasense-static.png[width="900"]

And now even DataMapper knows how to interact with our @Connector

image::datasense-static2.png[width="900"]

View connector full source code link:{resourcesDir}/java/v5/CookBookConnector.java[here].

==== My model is dynamic

In our previous section we covered the scenario when your model is static. Lets take a look into a much more complex scenario.

There are APIs that provide a way to get entities definitions dynamically. Salesforce, NetSuite are just some examples of this.

In our case, our CookBook provides an operation that describes our entities, so lets use that instead

==== Testing it

Show an unit test of DataSense.
Show how to test it in Studio.

=== Adding @Query

Use v2 and extend datasense to describe what can be queryable.
