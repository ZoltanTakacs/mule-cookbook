:imagesdir: ./images

:tutorial: Mule Cook Book
:author: MuleSoft Inc.
:toc: left
:icons: font
:numbered:
:website: http://mulesoft.org/
:muleJerveyVersion: 2.11

= Anypoint Studio Devkit

= Tutorial

== What is DevKit

The http://www.mulesoft.org/documentation/display/current/Anypoint+Connector+DevKit[DevKit] is an important part of the Anypoint Platform. It is a maven based tool that allows developers to build reusable components that not only can be run as part of a Mule application, but also can easily be configured/consumed from http://www.mulesoft.com/platform/mule-studio[Anypoint Studio]. 

== When to use it

There are several scenarios in which you may want to build your own connector. Yours might fall under one or more of this scenarios:

* You need to consume an API in one or more applications and you want to make sure everyone uses the same component. 
* You have an API and want to add strategic value to your business by providing a connector and telling the world "I am part of Mule Platform". 
* You want to facilitate integration with SaaS and on-premise Web services, applications, and data sources.
* The API we are consuming supports Pagination, Batch and/or has a SQL capability.
* The API we are consuming has different entity types and/or their structure can change.
* I want to extend Mule core.

= Prerequisites

To develop a connector you should have a working knowledge of Mule, Anypoint Studio, and Java development in general, specifically the use of Java annotations. 

DevKit's functionality is exposed to connector developers through http://docs.oracle.com/javase/tutorial/java/annotations/[Java annotations] that generate code and files to interact with Mule, and Anypoint Studio. The generated code provides the interface between the connector and Mule that would otherwise require each connector developer to include extensive boilerplate code, as well as the code and files required to interact with your connector in Anypoint Studio.

You can develop a connector using Windows, Mac, or Linux.

== Setup environment

* Download and install http://www.oracle.com/technetwork/java/javase/downloads/java-archive-downloads-javase7-521261.html[Java 1.7 JDK]. 
* Download and install http://maven.apache.org/download.cgi[Maven]. 
* Download http://www.mulesoft.com/platform/mule-studio[Anypoint Studio].
* Check http://www.mulesoft.org/documentation/display/current/Maven+Support+in+Anypoint+Studio[maven configuration] in Anypoint Studio.
* Install Anypoint DevKit plugin.
* Install a http://git-scm.com/downloads[GitHub] client.
* Clone https://github.com/mulesoft/mule-cookbook[tutorial] repository into your local machine.

WARNING: JRE is not suited for development, you need to have a JDK installed.

== Install Anypoint Devkit Plugin

Installing the DevKit plugin is as easy as installing any eclipse plugin.

The update site URL is already shipped in the update site list.

1. From the Help menu in *Anypoint Studio*, click *Install New Software*.
+
image::install-plugin-1.png[]

2. In the Install menu > Work with, click the down arrow and click Anypoint Addons Update Site. Click the checkbox for Anypoint DevKit Plugin, and click Next.
+
image::install-plugin-2.png[width="900"]

3. Proceed through all remaining steps in the wizard to install.

4. Restart Studio.

NOTE: If the Anypoint Addons Update Site is not available in the dropdown list, click Add and copy this URL to the repository Location: http://studio.mulesoft.org/r4/addons/beta

NOTE: This url is not an url you can explore, it is an update site that you can add in you Anypoint Studio.

= Build Your Connector

== What is a @Connector

A @Connector is a reusable component that knows how to interact with Mule, and with Anypoint Studio. 

From the developer point of view, it abstracts them from Mule interfaces required run in the platform, and the generation of the UI.

For the users, it abstracts them from the complexity of initializing any required element (connecting to a sandbox for example). A well developed connector makes your Mule apps much more simple by handling internally things like pagination, session expirations or input and output meta data. 

For a quick overview of the Anypoint Studio DevKit Plugin and how to create a basic Connector check the documentation.

== Features to cover in tutorial

In this tutorial we are going to  incrementally show you how to add value and simplify the connectors users interaction in Mule with the different features provided by DevKit.
We are going to start by generating a simple @Connector for a web service.
After that we will show you how to add configurable field (@Configurable) that will be used in our @Processor, and how to test it.
Then we are going to show you how to enrich the errors returned by an API and how to make sure your users don't need to handle session expirations.
As we understand more about the API being consumed, we will show you why we need to add DataSense to your connector and how it improves user experience.
Having DataSense also allow you to use our DataSense Query Language (DSQL).
Other important feature that most APIs support is the Pagination of results, as well as the Batch processing
For a full list of Supported annotations check our current documentation.

include::service-description.adoc[]

== Building a @Connector

Before start consuming our {tutorial} service, lets start by doing a Hello World Connector, and understanding the generated code.

Click *File* > *New*, then select *Anypoint Connector Project* or simple do a right click of the package explorer and select *New* > *Anypoint Connector Project*:

image::new-connector-1.png[width="700"]

Just put the name of your connector and click on finish:

image::new-connector-2.png[width="700"]

This generates a project containing the structure with all the required elements such as images, sample docs, and some basic tests for your connector.

image::new-connector-3.png[width="900"]

To enable the DevKit view select from the top bar *Window* > *Show view* > *Other* , and look for DevKit on the list.

image::enable-view.png[width="300", height="400"]

=== I have an API to build the @Connector

==== SDK Client

If you have an SDK all you need to do is to include the maven dependency for your jar.

For example in our case, to consume the SDK for the cookstore we can add the dependency.

[source,xml,indent=0]
----
<dependencies>
  <dependency>
    <groupId>foo.sdk.group.id</groupId>
    <artifactId>foo.sdk.artifact.id</artifactId>
    <version>${sdk.version}</version>
  </dependency>
</dependencies>
----

==== SOAP API

If you have a wsdl, the easiest way to build a connector is to create a client using cxf http://cxf.apache.org/docs/wsdl-to-java.html[wsdl2java].

You can configure the cxf goal in your pom.xml, very easily. The full documentation can by founded at http://cxf.apache.org/docs/maven-cxf-codegen-plugin-wsdl-to-java.html[cxf site].

For example in your pom.xml you can add this (plus all the dependencies required) :
[source,xml,indent=0]
----
<build>
  <plugins>
    <!-- CXF Code generation -->
    <plugin>
      <groupId>org.apache.cxf</groupId>
      <artifactId>cxf-codegen-plugin</artifactId>
      <version>${cxf.version}</version>
      <executions>
        <execution>
          <phase>clean</phase> <!-- This is so it work with the Devkit -->
          <goals>
            <goal>wsdl2java</goal>
          </goals>
          <configuration>
            <wsdlOptions>
              <wsdlOption>
                <wsdl>${basedir}/src/main/resources/wsdl/IMuleCookBookService.wsdl</wsdl>
                <autoNameResolution>true</autoNameResolution>
                <extendedSoapHeaders>false</extendedSoapHeaders>
                <extraargs>
                  <extraarg>-xjc-Xbg</extraarg>
                   <extraarg>-xjc-Xcollection-setter-injector</extraarg>
                  <extraarg>-p</extraarg>
                  <extraarg>org.mule.modules.wsdl.api</extraarg>
                </extraargs>
              </wsdlOption>
            </wsdlOptions>
          </configuration>
         </execution>
      </executions>
      <dependencies>
        <!-- Boolean getters -->
        <dependency>
          <groupId>org.apache.cxf.xjcplugins</groupId>
          <artifactId>cxf-xjc-boolean</artifactId>
          <version>${cxf.version.boolean}</version>
        </dependency>
        <!-- Collection Setters -->
        <dependency>
          <groupId>net.java.dev.vcc.thirdparty</groupId>
          <artifactId>collection-setter-injector</artifactId>
          <version>0.5.0-1</version>
        </dependency>
      </dependencies>
    </plugin>
  </plugins>
</build>
----

If you use the DevKit plugin it will generate everything for you, you just need to specify the wsdl location.

==== REST API
In this case, you have to write your client by hand. We recommend using Jersey {muleJerveyVersion} since it is the one provided by mule.
[source,xml,indent=0]
----
<dependencies>
  <dependency>
    <groupId>org.glassfish.jersey.core</groupId>
    <artifactId>jersey-client</artifactId>
    <version>{muleJerveyVersion}</version>
  </dependency>
</dependencies>
----

=== Understanding the a Connector structure

Your Connector basically consists of a set of http://www.mulesoft.org/documentation/display/current/Message+Processors[message processors] and configurable elements users populate in order to consume the API your connector was developed for.


After you install your connector by right-clicking the connector and clicking *Anypoint Connector* > *Install or Update*, completing the prompts, and restarting Studio, you will be able to properly open the Mule application that is being used in the connector test that was generated for your connector.

Lets check the structure of this dummy connector:

In this image you will be able to see how most of the code is mapped into UI elements.

TODO: Use 2 images of screenshots with the default layout

image::split-1-high.png[caption="Figure 1: ", title="View Structure and UI", alt="Image1", width="300", height="200", link="images/split-1-high.png"]

In this one, you can check how the code matches to XML and other UI elements.

TODO: Use 2 images of screenshots with the default layout

image::split-2-high.png[caption="Figure 2: ", title="View configuration and XML", alt="Image2", width="300", height="200", link="images/split-2-high.png"]

=== Connecting to my service

When consuming a service there you may need to configure different values in order to establish a connection. 

To solve this, the DevKit provides a pair of annotations that allows developer to modularize in one class the behaviour exposed to the users (using the @Connector annotation) and in a different one the code related to the the connection.

By marking a field with @org.mule.api.annotations.ConnectionStrategy the DevKit will make sure that you have an initialized object set when the Mule app is running and a request is made to your connector.

If there is no need for authentication and/or connection management but you need to configure some things, you can have a class marked with @org.mule.api.annotations.components.Configuration.

If you actually need an authentication there are several annotations that will help you achieve the desired behaviour as we will see in this tutorial.

To go deeper into this feature, check the http://www.mulesoft.org/documentation/display/current/Authentication[current documentation].

Let start coding and create a connector that allows us to get the recently added elements.

Since the {tutorial} service description says we don't need any kind of authentication to consume the recently added recipies, this is the best operation we can use to start learning how to build our @Connector.

Create a new Anypoint Connector Project with the following configuration and don't forget to uncheck the default generation:

image:new1.png[width="700"]

After that lets add our client dependency so that we can use it in our connector.

In your pom.xml add:

[source,xml,indent=0]
----
<dependencies>
  <dependency>
    <groupId>org.mule.tools.devkit.cookbook</groupId>
    <artifactId>sdk-client</artifactId>
    <version>1.0.0</version>
  </dependency>
</dependencies>
----

==== I don't need a authentication

Here even if we don't need to authenticate against our sandbox, we still need to initialize the client before consuming the service.

Anypoint Connectors can be fully aware of http://www.mulesoft.org/documentation/display/34X/Integrating+Connectors+with+the+Mule+Lifecycle[Mule's lifecycle] without implementing any Mule specific interface. There is one method annotation for each of the four phases of Mule lifecycle. If a method is annotated with one of these annotations it will be invoked during the Mule lifecycle phase that annotation represents.

We are going to use the @Start to initialize our client.

[source,java]
----
    private MuleCookBookClient client;

    @Start
    public void initialize(){
    	client = new MuleCookBookClient(connectionStrategy.getAddress());
    }
----

If you want, you can continue and directly implement your connector with connection management, if not, just go to the add your first <<configurable,configurable>>.

==== Using connection Management

TODO

Use v1 to show how connection management works

===== Testing Connection is Working

TODO

Use v1 to show in studio how the Test Connection works

==== Using OAuthV2

TODO

Use v1 to show how to implement OAuthV2 in your connector
[[configurable]]
=== Adding configurable fields

Adding configurable fields is also easy with the plugin since there are a couple of templates ready for you to use.

Just type "conf" at the editor of your @Connector or your connection strategy and use Ctrl + Space bar to display the templates.

image::config1.png[width="900"]

In our case, lets at a configurable field in our @Configuration component with a default value for the endpoint our client will connect to.

This way we will allow users to connect to different sandboxes.

image::config2.png[width="900"]

We are now ready to add our first processor. If you want a little more details about configurable fields, continue reading. If not, lets just go to add our <<processor,processor>>.

==== @Optional

Optional parameters or configurable ones, as the name states, are elements that are not required, and there for, there is no need for users to specify a value.

Configurable fields can be specified inside @Connector or Connection Strategies Classes, or as parameters of @Processor methods inside a @Connector.

[source,java]
----
import org.mule.api.annotations.Configurable;
import org.mule.api.annotations.Processor;
import org.mule.api.annotations.param.Optional;

//Inside the @Connector class

/**
 * Optional Field documentation
 */
@Configurable
@Optional
private String  optionalField;
//Getter and Setter of the field are required

/**
 * Optional parameter
 */
public String sayHi(String firstName,@Optional String lastName ) {
    return "Hi "+firstName+" "+((lastName==null) ? "":lastName);
}
----

==== @Default

When you want an optional parameter or configurable you can avoid the use of @Optional and just use the @Default annotation.
[source,java]
----
import org.mule.api.annotations.Configurable;
import org.mule.api.annotations.Processor;
import org.mule.api.annotations.param.Default;

//Inside the @Connector class

/**
 *  Field with Default
 */
@Configurable
@Default("Hi")
private String  greeting;
//Getter and Setter of the field are required

/**
 * Default parameter
 */
public String sayHi(String firstName,@Default("Unknown") String lastName ) {
    return greeting+" "+firstName+" "+lastName;
}
----

Another very important use of the @Default annotation is when building a connector that has DataSense.
[[processor]]
=== Adding operations to my @Connector (@Processor)

To add a processor simply type "proc" at the editor and use Ctrl + Space bar to display the templates and pick the simple processor.

image::processor1.png[width="900"]

Lets change it to reflect the getRecentlyAdded method signature, and there we have..our first connector, ready to be tested.

image::processor2.png[width="900"]

==== Adding samples to your connector

Lets now add the example for it.

First create the file pointed by the *{@sample ...}*

NOTE: When you add an example, the name provided here is the name that narrows the example in the file. Inside of it you have to put an example of the @Processor.

If you have the the Javadoc check enabled, DevKit plugin will mark the missing example as an error and provide a quick fix for us to easily add the example.

Otherwise, open the file and type "<" at the editor and use Ctrl + Space bar to display the templates and pick the one that best suite our operation.

image::sample1.png[width="900"]

Our example in this case looks like this:

[source,xml,indent=0]
----
<!-- BEGIN_INCLUDE(cook-book:getRecentlyAdded) -->
	<cook-book:get-recently-added/>
<!-- END_INCLUDE(cook-book:getRecentlyAdded) -->
----

=== Testing your @Processor

In order to test our @Processor, lets start by generating the required files for us to test the operation, as if it was being used inside a mule application.

Right click the root of your project and select *Anypoint Connector > Generate Tests*.

Select the operation you want to use to generate the test, and all the files you want to create.

After the generation ends, just modify the test to make the corresponding setup and assertions.

image::generate-tests1.png[width="900"]

Start the server, and run your test now.

It is all green!

image::generate-tests2.png[width="900"]

So..what just happened?

* We run a mule app that contains one simple flow with the xml that represents our operation.
* A connector instance was created and using our configuration, it connected to the server.
* The operation was executed and the payload now is the result of that operation
* We retrieve the payload, cast it to what we know the result is and started making the relevant assertions.

To go deeper into our testing best practices please read the full http://www.mulesoft.org/documentation/display/current/Developing+DevKit+Connector+Tests[testing documentation].

== Improving error Handling

=== Exception Handling (@Handler)

TODO

Use v1 with the @Handler to improve the errors returned to the user

=== How to handle session expiration (@ReconnectOn)

TODO

Use v1 with the @ReconnectOn to show users how to create a @Processor capable of triggering reconnections

include::datasense.adoc[]

== Adding Pagination 

TODO

A quick example of Pagination with the query operation

=== Testing it

TODO

== Adding Batch 

=== What is it?

TODO

=== Implement it in your connector

TODO

Add batch to the operations that handle list of elements

=== Testing it

TODO

== Installing my @Connector 

TODO

Show how to install it using the plugin.
Show how to install it without it.

=== Debugging your @Connector

After successfully installing your connector, you can start using your connector in a Mule App.
By simple putting a breakpoint on your source code of the connector, you will be able to debug it.
If your connector is a Community connector the source code will be shipped automatically in the installed connector. 
If your connector is an Enterprise, you will need to manually attach the source code of your jar.
WARNING: In order to correctly debug your code, take into account that the Mule app you are running is using the latest installed version, so if you did some changes, and you want to debug the Mule app, you need to install the connector again.

Debugging your connector when running your test, is as simple as debugging any java class.

You just need to put a break point on your connector

=== Documenting my @Connector
Show how to document your connector and the samples. < Current Doc >

=== Sharing my @Connector
Connector, as a component that can be installed in Anypoint Studio, is an Update Site.
Update Sites are used to organize and export features so they can be installed into Eclipse applications.

When the site is built, the included features (along with all plug-ins part of those features) will be exported into an installable form. The exported plug-ins and features will be put into two folders "plug-ins" and "features". Two other files, "content.xml" and "artifacts.xml" will also be generated and contain metadata for the exported files that make installing easier. These files, along with "site.xml", collectively form an Eclipse update site. To make the update site available to others you must make all these files available in a shared directory or web site.

When building a connector, DevKit generates this for you, so that you don't need to worry about generating this. 

You can use the Anypoint DevKit plugin to either install the connector on your current Studio, or export it as an update-site for others to use.

== Other Features

=== Adding @Source

==== What is a @Source
In some cases it is necessary to create Message Sources instead of Message Processors. 

Basically, a Message Source receives or generates new messages to be processed by Mule.
One of the use cases of Message Sources is implementing Streaming APIs. The @Source annotation marks a method inside a @Connector annotated class as callable from a Mule flow and capable of generating Mule events. Each marked method will have a Message Source generated. The method must receive a SourceCallback as one of its arguments that represents the next message processor in the chain. It does not matter the order in which this parameter appears as long it is present in the method signature.

==== Create a @Source 
Create a @Source that consumes the Get Recently Updated on the Connector
Show how to use it in an app. Video of user drag and dropping into the canvas and configuring it.

==== Test my @Source

TODO

=== Adding @Transformer

TODO

==== What is a @Transformer
Transformers convert message payloads to formats expected by their destinations. Mule ESB provides many standard transformers, which you configure using predefined elements and attributes in your Mule XML configuration file but sometimes is useful to build custom transformers.

Annotating a method with @Transformer signals the Mule DevKit to export this method functionality as a transformer. Transformers need to be declared in classes annotated with @Module or @Connector and many transformers can be declared in the one class. It is possible to declare transformers, message processors and message sources in the same class.
The @Transformer annotated method must follow certain rules:

* It must be static
* It must be public
* It must not return void
* It must not return java.lang.Object
* It must receive exactly one argument
* It must be inside a class annotated with @Connector

==== Creating a transformer 

TODO

From String Json representation to Entity

==== Using the transformer in a Mule app

TODO

Show how it is used with auto discovery

Show how it is used explicitly

==== Test my @Transformer

TODO

=== Improve UI Layout

TODO

==== Using friendlyName

TODO

Show how to change the display name of the @Connector

==== Using @Password

==== Using @Placement

=== Understanding @RefOnly

Explain the annotation and show how to use it and the impact on the UI this has.
